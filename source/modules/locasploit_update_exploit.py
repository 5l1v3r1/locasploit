#!/usr/bin/env python3
from source.modules._generic_module import *

class Module(GenericModule):
    def __init__(self):
        self.authors = [
            Author(name='Vitezslav Grygar', email='vitezslav.grygar@gmail.com', web='https://badsulog.blogspot.com'),
        ]
        
        self.name = 'locasploit.update.exploit'
        self.short_description = 'Updates CVE-exploit relationships.'
        self.references = [
            '',
        ]
        
        self.date = '2017-02-02'
        self.license = 'GNU GPLv2'
        self.version = '0.0'
        self.tags = [
            'locasploit',
            'update',
            'exploit',
            'exploitdb', 'exploit-db',
        ]
        self.description = """
This module parses http://cve.mitre.org/data/refs/refmap/source-EXPLOIT-DB.html and updates vuln.db database.

"""
        
        self.dependencies = {
        }
        self.changelog = """
"""

        self.reset_parameters()

    def reset_parameters(self):
        self.parameters = {
            'SILENT': Parameter(value='no', mandatory=True, description='Suppress the output'),
            'BACKGROUND' : Parameter(value='yes', mandatory=True, description='yes = run in background, no = wait for it...'),

        }

    def check(self, silent=None):
        if silent is None:
            silent = positive(self.parameters['SILENT'].value)
        result = CHECK_PROBABLY
        # check parameters
        silent = positive(self.parameters['SILENT'].value)
        if not positive(self.parameters['BACKGROUND'].value) and not negative(self.parameters['BACKGROUND'].value):
            if not silent:
                log.err('Bad %s value: %s.', 'BACKGROUND', self.parameters['BACKGROUND'].value)
            result = CHECK_FAILURE

        # can import urlib and xml.etree.ElementTree?
        try:
            from urllib.request import urlretrieve
        except:
            if not silent:
                log.err('Cannot import urllib.request library (urllib5).')
            # TODO other ways?
            result = CHECK_FAILURE
        try:
            import xml.etree.ElementTree as etree
        except:
            if not silent:
                log.err('Cannot import xml.etree.ElementTree.')
            result = CHECK_FAILURE
        
        return result
    
    def run(self):
        silent = positive(self.parameters['SILENT'].value) 
        # # # # # # # #
        #t = Thread(silent, int(self.parameters['TIMEOUT'].value))
        t = Thread(silent)
        if positive(self.parameters['BACKGROUND'].value):
            return t
        t.start()
        t.join()
        # # # # # # # #
        return None
    
        
class Thread(threading.Thread):
    def __init__(self, silent):
        threading.Thread.__init__(self)
        self.silent = silent
        self.terminate = False
    
    def run(self):
        from urllib.request import urlretrieve
        from urllib.error import HTTPError
        from html.parser import HTMLParser

        # HTML Parser
        class HTMLP(HTMLParser):
            def __init__(self):
                super().__init__()
                self.intable = False
                self.tmpkey = ''
                self.tmpvalue = []
                self.result = {}

            def handle_starttag(self, tag, attrs):
                if tag == 'table':
                    self.intable = True
                    self.tmpkey = ''

            def handle_endtag(self, tag):
                if self.intable and tag == 'table':
                    self.add_previous_to_result()
                    self.intable = False
                    self.tmpkey = ''

            def add_previous_to_result(self):
                if self.tmpkey != '':
                    self.result[self.tmpkey] = self.tmpvalue

            def handle_data(self, data):
                if self.intable and len(data.strip())>0:
                    if data.startswith('EXPLOIT-DB:'):
                        self.add_previous_to_result()
                        self.tmpkey = data
                        self.tmpvalue = []
                    elif data.startswith('CVE-') and len(self.tmpkey)>0:
                        self.tmpvalue.append(data)
                        
           # END OF HTML PARSER

        localfile = './vulnerabilities/exploit.html'
        try:
            urlretrieve('http://cve.mitre.org/data/refs/refmap/source-EXPLOIT-DB.html', localfile)
        except HTTPError:
            log.warn('Cannot get exploit data.')

        if self.terminate:
            return
        data = io.read_file('/', localfile)
        
        if data == IO_ERROR:
            log.err('Cannot read exploit data.')
            return

        parser = HTMLP()
        parser.feed(data) 
        #print(parser.result)
        if self.terminate:
            return
        db['vuln'].add_exploits(parser.result)
        if not self.silent:
            log.ok('Exploits updated.')
        """    
            actuples = []
            cvetuples = []
            cves = [x for x in root if 'type' in x.attrib.keys() and x.attrib['type']=='CVE' and not ('reject' in x.attrib.keys() and x.attrib['reject']=='1')]
            #cves = cves[:10]
            for cve in cves:
                # should not stop?
                if self.terminate:
                    break
                # insert into db
                cveid = cve.attrib['name']
                if year == 'Modified':
                    cveyear = cve.attrib['seq'][:4]
                    modified_years_to_update.add(cveyear if cveyear>'2002' else '2002')

                #print(cveid)
                description = cve.find('%sdesc' % p).find('%sdescript' % p).text
                cvetuples.append((cve.attrib, description))
                #lib.db['vuln'].add_cve(cve.attrib, description)
    
                vs = cve.find('%svuln_soft' % p)
                
                if vs is None:
                    products = []
                else:
                    products = vs.findall('%sprod' % p)
                for product in products:
                    #print('   ', product.attrib['vendor'], product.attrib['name'])
                    for version in product.findall('%svers' % p):
                        # prepare for insertion
                        if 'prev' not in version.attrib:
                            version.attrib['prev'] = 0
                        actuples.append((cveid, product.attrib['name'], product.attrib['vendor'], version.attrib['num'], version.attrib['prev']))
            # push into db
            #print('-------- pushing into DB (%d cves, %d acs)' % (len(cvetuples), len(actuples)))
            lib.db['vuln'].add_cves(cvetuples)
            lib.db['vuln'].add_apps_for_cves(actuples)
        
        # from 'Modified' year? Update checksums for altered years
        if 'Modified' in self.years:
            log.info('Updating checksums for modified years...')
            updated_years = self.download_years(modified_years_to_update)
        else:
            updated_years = years_to_update
        for year, sha1 in updated_years.items():
            lib.db['vuln'].add_property('%s_sha1' % (year), sha1)
        
        lib.db['vuln'].add_property('last_update', datetime.now().strftime('%Y-%m-%d'))
        """
        
    # terminates the thread
    def stop(self):
        self.terminate = True
    

lib.module_objects.append(Module())
